use std::{fs, env};
fn main() {
    let args: Vec<String> = env::args().collect();
    let mut input_filename: &String = &String::from("pattern.txt");
    let mut key: u8 = 1; 
    let mut output_filename: &String = &String::from("output.txt");
    let mut output_filename_image: &String = &String::from("output.pbm");
    let mut width: usize = 100;
    if args.len() >= 3 {
        input_filename = &args[1];
        key = args[2].trim().parse().unwrap();
        output_filename= &args[3];
        output_filename_image= &args[4];
        width= args[5].trim().parse().unwrap();
    }

    let pattern = open_file(input_filename)
        .expect("error reading file");

    if key == 1 {
        create_image(output_filename_image, &pattern, width);
        let compressed_pattern = compress(pattern)
            .expect("error with compressing");

        write_file(output_filename, compressed_pattern)
            .expect("error writing file");
    } else if key == 0 {
        let decompressed_pattern = decompress(pattern, width)
            .expect("error with decompressing");
        println!("{}", decompressed_pattern);
        create_image(output_filename_image, &decompressed_pattern, width);
        write_file(output_filename, decompressed_pattern)
            .expect("error writing file");
    }
}

fn open_file(filename: &str) -> Result<String, std::io::Error> {
    let contents = fs::read_to_string(filename)?;

    Ok( contents )
}

fn write_file(filename: &str, contents: String) -> Result<(), std::io::Error> {
    fs::File::create(filename)?;
    fs::write(filename, contents)?;

    Ok(())
}

fn compress(string: String) -> Result<String, std::io::Error> {
    let mut last_char = '2';
    let mut a: usize = 1;
    let mut return_string: String = String::from("");
    for (i, c) in string.chars().enumerate() {
        if c != '\n' {
            if i == 0 {

            } else if c == last_char {
                a += 1;
            } else {
                return_string += &a.to_string();
                return_string += ",";
                a = 1;
            }
            if i == string.len()-1 {
                return_string += &a.to_string();
                return_string += ",";
            }
            last_char = c;
        }
    }
    Ok( return_string )
}

fn decompress(string: String, width: usize) -> Result<String, std::io::Error> {
    let mut a: u8 = 0;
    let mut b: u8 = 1;
    let mut line: String = String::from("");
    let mut return_string: String = String::from("");
    for (_i, c) in string.chars().enumerate() {
        if c == ',' {
            for _i in 0..a {
                line.push((b + 48) as char);
                if line.len() == width {
                    return_string.push_str(&line);
                    return_string.push('\n');
                    line = String::from("");
                }
            }
            if b == 0 {
                b = 1;
            } else {
                b = 0;
            }
            a = 0;
        } else {
            a *= 10;
            a += c as u8 - 48;
        }
    }
    return_string.remove(return_string.len()-1);
    Ok( return_string )
}

fn create_image(filename: &str, contents: &String, width: usize) {
    let mut my_string = String::from("P1\n");
    my_string.push_str("# This image was generated by rust\n");
    my_string.push_str(&width.to_string());
    my_string.push(' ');
    my_string.push_str(&(contents.len() / width).to_string());
    my_string.push('\n');
    for i in  contents.chars() {
        my_string.push(i);
        my_string.push(' ');
    }
    write_file(filename, my_string)
        .expect("error generating image");
}